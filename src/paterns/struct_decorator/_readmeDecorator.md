Паттерн Decorator (Декоратор) в основном используется для динамического добавления нового поведения или функциональности объектам, не изменяя их основной структуры. Основные цели использования паттерна Decorator в промышленной разработке включают:

1. **Расширение функциональности объектов**: Decorator позволяет добавлять новое поведение <br> 
или функциональность объектам без изменения их кода. Это полезно, <br>
когда требуется динамически расширить функциональность объекта или добавить <br>
несколько различных декораторов для одного объекта.

2. **Избежание наследования классов**: В отличие от наследования, который может привести <br>
к созданию большого числа подклассов для каждой комбинации поведения,<br>
Decorator позволяет компоновать объекты в различные комбинации,<br>
обеспечивая гибкость и избегая излишнего использования наследования.<br>


3. **Обеспечение открытости для расширения и закрытости для изменения**: <br>
Decorator позволяет добавлять новые функции к существующим объектам без изменения их кода, <br>
что соответствует принципу открытости для расширения и <br>
закрытости для изменения (Open/Closed Principle).


4. **Реализация прозрачной обертки**: Decorator позволяет создавать обертки вокруг объектов, <br>
которые выглядят и ведут себя как исходные объекты. Это значит, что клиентский <br>
код может работать с обернутыми объектами так же, как и с исходными, не зная о наличии декоратора.<br>


5. **Уменьшение "толстых" классов**: Decorator позволяет разделить функциональность <br>
на отдельные классы, каждый из которых отвечает за определенный аспект поведения объекта. <br>
Это помогает уменьшить размер "толстых" классов и делает код более читаемым и поддерживаемым.<br>


Таким образом, паттерн Decorator обеспечивает гибкость, расширяемость и возможность <br>
добавления нового функционала объектам без изменения их кода, что делает его очень <br>
полезным в промышленной разработке.


Пример использования паттерна Decorator в промышленной разработке <br>
можно найти в области веб-разработки, особенно в контексте обработки <br>
HTTP-запросов. 


Представим, что у вас есть веб-приложение, которое <br>
обрабатывает HTTP-запросы от клиентов. Вы хотите добавить дополнительную <br>
функциональность к этим запросам, такую как аутентификация, авторизация, <br>
логирование и сжатие данных. Вместо того чтобы создавать множество классов <br>
для каждой комбинации функциональности, вы можете использовать паттерн <br>
Decorator. Рассмотрим пример с обработкой запросов на авторизацию и <br>
логирование. У вас есть основной класс, который обрабатывает <br>
HTTP-запросы, и два декоратора, которые добавляют дополнительную <br>
функциональность.